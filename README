I first became aware of Base64 when I started exchanging messages on Fidonet in the mid-90s, at least I think I did, I only remember seeing a strange variety of letters and numbers that would somehow represent an 8-bit file in a message composed of 7-bit ASCII characters. For a long time I was completely ignorant on how a file could be encoded into Base64 and decoded back again. Then one day, I needed to squeeze a sequence of bytes into a JSON object, and then I wrote a quick and dirty implementation in Javascript. Some time later, as an exercise in C programming, I wanted to see how simple I could make the code by using pointers and data types.

Base64 works simply by combining three 8-bit bytes together to form a 24-bit byte, 24 being the lowest common multiple of both 8 and 6. This conflated byte is then split into four 6-bit bytes. In order to represent these smaller bytes in a string of text, the characters A-Z, a-z, 0-9, +, and /, are conventionally used. If the number of bytes being encoded into Base64 isn't exactly divisible by three, and is missing either one or two, then additional '=' characters are added to the encoded string to represent each missing byte. The number of bytes in the final product is therefore always precisely divisible by four. It's worth mentioning that as a consequence of representing 6-bit data back as an 8-bit byte, an extra third is added to the final length of the encoded data.

The implementation that follows is quite simplistic, and similar to the base64 command found on common \*nix distributions, reads from stdin and outputs to stdout. Similarly a single argument, -d, is used to switch from the default setting of encode, to decode. There's a little pointer magic used when looking up the 6-bit representation, but when decoding, a combination of switch and case commands are used to find the required 8-bit value. This doesn't appear to be very elegant, and I could have used nested if statements instead, but I find the current solution straight-forward, readable, and more likely to compile-down to clean and efficient code. Fortunately most of the work is done with bit shifting and masking, which is something computers can perform very quickly.